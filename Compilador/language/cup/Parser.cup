package com.language.parser;

import java.util.*;
import java_cup.runtime.*;
import com.language.model.program.*;
import com.language.model.expression.*;
import com.language.model.statement.*;
import com.language.exceptions.*;
import java.util.LinkedList;
import java.util.List;
import java.util.Collections;


action code {:

	private boolean breakFlag;
	private int breakLine = 0;
	private int breakColumn = 0;
	
	private boolean continueFlag;
	private int continueLine = 0;
	private int continueColumn = 0;
	
	public void setBreakFlag(boolean value) {
		breakFlag = value;
		//breakLine = line;
		//breakColumn = column;
	}
	
	public void setContinueFlag(boolean value) {
		continueFlag = value;
		//continueLine = line;
		//continueColumn = column;
	}

	public void checkBreakContinueErrors() {
		if (breakFlag) {
			throw new ParsingException(breakLine, breakColumn, "Sintaxis incorrecta: break");
		}
		if (continueFlag) {
			throw new ParsingException(continueLine, continueColumn, "Sintaxis incorrecta: continue");
		}
	}
	
 :}; 




terminal String ID, INTEGER, LONG, FLOAT, STRING, TRUE, FALSE;

terminal String ASSIGN, PLUS, MINUS, MUL, DIV, EXP, INT_DIV, MOD;

terminal String AND_BIT, OR_BIT, XOR_BIT, NOT_BIT, LSHIFT_BIT, RSHIFT_BIT;

terminal String AND, OR, NOT, EQUALS, NOT_EQUALS, LESS_THAN, GREAT_THAN, LESSEQUAL_THAN, GREATEQUAL_THAN;

terminal String PRINT, TYPE;

terminal String NEWLINE;

terminal String START_BLOCK, END_BLOCK;

terminal String IF, ELSE, DEF, WHILE;

terminal String LEFTPARENTHESE, RIGHTPARENTHESE;

terminal String COLON, SEMICOLON, COMMA;

terminal String BREAK, CONTINUE;

terminal String LEFTLLAVE, RIGHTLLAVE, LEFTRECT, RIGHTRECT;


non terminal program, module;
non terminal statement_newline_list, simple_statement_list, simple_statement, compound_statement;
non terminal stmt_list, simple_stmt_semicolon_list, statement, statement_list, identifier_comma_list;
non terminal Expression expression, simple_expression, map_expression, tuple_expression, list_expression;
non terminal expression_map_list, expression_tuple_list, expression_list_list;
non terminal block;

precedence left IF, ELSE;
precedence left ASSIGN;
precedence left PLUS, MINUS;
precedence left MUL, DIV, EXP, INT_DIV, MOD;
precedence left AND, OR, EQUALS, NOT_EQUALS, LESS_THAN, GREAT_THAN, LESSEQUAL_THAN, GREATEQUAL_THAN;
precedence left AND_BIT, OR_BIT, XOR_BIT, LSHIFT_BIT, RSHIFT_BIT;
precedence right ID, LEFTRECT;


program	::=	module:list {: 
							Collections.reverse((List<Statement>)list);
							RESULT = new Program((List<Statement>)list);
						:};
						
module ::= simple_statement:stmt simple_statement_list:list {:
						 										((List<Statement>)list).add((Statement)stmt);
																RESULT = list;
															:}
		   | statement_newline_list:list {: 
		   									RESULT = list; 
		   								 :};
		   								 
statement_newline_list ::=	NEWLINE statement_newline_list:list {:
																	RESULT = list; 
																:} 
							| statement:stmt statement_newline_list:list {: 
																			((List<Statement>)list).addAll((List<Statement>)stmt);
																			RESULT = list;
																		 :}
							| 			
							/*epsilon*/							
							{: 
								RESULT = new LinkedList<Statement>(); 
							:}; 
															
simple_statement_list ::= simple_statement:stmt simple_statement_list:list {: 	
																				((List<Statement>)list).add((Statement)stmt);
																				RESULT = list;
																			:}
						  | 
						  /* epsilon */
						  {: 
						  	RESULT = new LinkedList<Statement>(); 
						  :};
						  
simple_statement ::= expression:e {: RESULT = e; :} 
					 | ID:i ASSIGN expression:e {: RESULT = new AssignStatement(i, (Expression)e); :}
					 | PRINT:p expression:e {: RESULT = new PrintStatement((Expression) e); :}
					 | TYPE:t LEFTPARENTHESE expression:e RIGHTPARENTHESE {: RESULT = new TypeStatement((Expression) e);	:}
					 | BREAK :b  {: setBreakFlag(true);
									RESULT = new BreakStatement(); 
								:}
					 | CONTINUE :c {: setContinueFlag(true);
									  RESULT = new ContinueStatement(); :}
					 | ID:i LEFTRECT expression:k RIGHTRECT ASSIGN expression:e {: IdentifierExpression id = new IdentifierExpression(i);
					 																RESULT = new AssignStructuredTypeStatement(id, e, k);
					 															:};

expression ::= INTEGER:i {: RESULT = new IntegerExpression(Integer.valueOf(i)); :}
					| STRING:s {: RESULT = new StringExpression(s); :}
					| LONG:l {: RESULT = new LongExpression(l); :}
					| FLOAT:f {: RESULT = new FloatExpression(Float.valueOf(f)); :}
					| TRUE:b {: RESULT = new BooleanExpression(true); :}
					| FALSE:b {: RESULT = new BooleanExpression(false); :}	
					| ID:i {: RESULT = new IdentifierExpression(i); :}
					| LEFTPARENTHESE expression:e RIGHTPARENTHESE {: RESULT = e; :}
			| expression:l PLUS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "+", (Expression)r) ;:}
			| expression:l MINUS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "-", (Expression)r) ;:}
			| expression:l DIV expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "/", (Expression)r) ;:}
			| expression:l MUL expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "*", (Expression)r) ;:}
			| expression:l EXP expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "**", (Expression)r) ;:}
			| expression:l INT_DIV expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "//", (Expression)r) ;:}
			| expression:l MOD expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "%", (Expression)r) ;:}
			| expression:l AND expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "and", (Expression)r) ;:}
			| expression:l OR expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "or", (Expression)r) ;:}
			| expression:l EQUALS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "==", (Expression)r) ;:}
			| expression:l NOT_EQUALS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "!=", (Expression)r) ;:}
			| expression:l LESS_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "<", (Expression)r) ;:}
			| expression:l LESSEQUAL_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "<=", (Expression)r) ;:}
			| expression:l GREAT_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, ">", (Expression)r) ;:}
			| expression:l GREATEQUAL_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, ">=", (Expression)r) ;:}
			| expression:l AND_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "&", (Expression)r) ;:}
			| expression:l OR_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "|", (Expression)r) ;:}
			| expression:l XOR_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "^", (Expression)r) ;:}
			| expression:l LSHIFT_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "<<", (Expression)r) ;:}
			| expression:l RSHIFT_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, ">>", (Expression)r) ;:}
			| MINUS expression:e {: RESULT = new UnaryOperationExpression("-", (Expression)e); :}
			| NOT_BIT expression:e {: RESULT = new UnaryOperationExpression("~", (Expression)e); :}
			| NOT expression:e {: RESULT = new UnaryOperationExpression("not", (Expression)e); :}
			| tuple_expression:e {: RESULT = e; :}
			| map_expression:e {: RESULT = e; :}
			| ID:i LEFTRECT expression:e RIGHTRECT {:	IdentifierExpression id = new IdentifierExpression(i); 
											   			RESULT = new StructuredTypePositionExpression(id, e, null);
											   	   :}
			| ID:i LEFTRECT expression:s COLON RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 RESULT = new StructuredTypePositionExpression(id, s, null);
											   	   					  :}
			| ID:i LEFTRECT  COLON expression:s RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 RESULT = new StructuredTypePositionExpression(id, s, null);
											   	   					  :}
			| ID:i LEFTRECT expression:s COLON expression:e RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 RESULT = new StructuredTypePositionExpression(id, s, e);
											   	   					  :}
			| ID:i LEFTRECT  COLON RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 					RESULT = new StructuredTypePositionExpression(id, null, null);
											   	   					  					 :}
			| ID:i LEFTRECT  COLON COLON expression:f RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 					RESULT = new StructuredTypePositionExpression(id, null, f);
											   	   					  					 :}
			| ID:i LEFTRECT  COLON expression:s COLON expression:f RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 					RESULT = new StructuredTypePositionExpression(id, s, f);
											   	   					  					 :}
			| ID:i LEFTRECT expression:s COLON COLON expression:f RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 					RESULT = new StructuredTypePositionExpression(id, s, f);
											   	   					  					 :}
			| ID:i LEFTRECT expression:s COLON expression:e COLON expression:f RIGHTRECT {: IdentifierExpression id = new IdentifierExpression(i); 
											   							 					RESULT = new StructuredTypePositionExpression(id, s, e);
											   	   					  					 :}
			| list_expression:e {: RESULT = e; :};


map_expression ::= LEFTLLAVE expression_map_list:list RIGHTLLAVE {: RESULT = new DictionaryExpression((Map<Expression,Expression>)list); :}
				| LEFTLLAVE NEWLINE expression_map_list:list RIGHTLLAVE {: RESULT = new DictionaryExpression((Map<Expression,Expression>)list); :};

expression_map_list ::= expression:key COLON expression:val COMMA NEWLINE expression_map_list:list {: ((Map<Expression,Expression>)list).put((Expression)key,(Expression)val);
																									  RESULT = list;
																									:} 
					| expression:key COLON expression:val COMMA expression_map_list:list {: ((Map<Expression,Expression>)list).put((Expression)key,(Expression)val);
																							RESULT = list;
																						  :}
					|expression:key COLON expression:val {: Map<Expression, Expression> map = new HashMap<Expression, Expression>();
															map.put(key,val);
															RESULT = map;
														 :}
					|expression:key COLON expression:val NEWLINE {: Map<Expression, Expression> map = new HashMap<Expression, Expression>();
															map.put(key,val);
															RESULT = map;
														 :}
					| /*epsilon*/{: RESULT = new HashMap<Expression, Expression>(); :};

tuple_expression ::= LEFTPARENTHESE expression:e COMMA expression_tuple_list:list RIGHTPARENTHESE {: ((ArrayList<Expression>)list).add(0,e); 
																									RESULT = new TupleExpression((ArrayList<Expression>)list); 
																								  :}
					| LEFTPARENTHESE RIGHTPARENTHESE {: ArrayList<Expression> tuple = new ArrayList<>();
														RESULT = new TupleExpression(tuple);
													 :};

expression_tuple_list ::= expression:e COMMA expression_tuple_list:list {: ((ArrayList<Expression>)list).add(0,e);
																		    RESULT = list;
																		:}
						| expression:e {: ArrayList<Expression> tuple = new ArrayList<>();
										  tuple.add(0,e);
										  RESULT = tuple;
									   :}
						| /* epsilon */ {: RESULT = new ArrayList<Expression>(); :};

list_expression ::= LEFTRECT expression:e COMMA expression_tuple_list:list RIGHTRECT {: ((ArrayList<Expression>)list).add(0,e); 
																									RESULT = new TupleExpression((ArrayList<Expression>)list); 
																								  :}
					| LEFTRECT RIGHTRECT {: ArrayList<Expression> tuple = new ArrayList<>();
														RESULT = new TupleExpression(tuple);
													 :};

expression_list_list ::= expression:e COMMA expression_list_list:list {: ((ArrayList<Expression>)list).add(0,e);
																		    RESULT = list;
																		:}
						| expression:e {: ArrayList<Expression> tuple = new ArrayList<>();
										  tuple.add(0,e);
										  RESULT = tuple;
									   :};


compound_statement ::= IF expression:e COLON block:i ELSE COLON block:b {: RESULT = new IfStatement(e, (List<Statement>) i,(List<Statement>) b ); :}
					   | IF expression:e COLON block:b {: RESULT = new IfStatement(e, (List<Statement>) b, null); :}
					   | WHILE expression:e COLON block:b {: setContinueFlag(false);
															 setBreakFlag(false); 
					   										 RESULT = new WhileStatement(e, (List<Statement>) b); 
					   									  :}
					   | DEF ID LEFTPARENTHESE RIGHTPARENTHESE COLON block
					   | DEF ID LEFTPARENTHESE ID identifier_comma_list RIGHTPARENTHESE COLON block;
					   
stmt_list ::= simple_statement:stmt simple_stmt_semicolon_list:list {: 	((List<Statement>)list).add((Statement)stmt); 
																		RESULT = list;
																	:};
																	
simple_stmt_semicolon_list ::= SEMICOLON simple_statement:stmt simple_stmt_semicolon_list:list {: 
																									((List<Statement>)list).add((Statement)stmt); 
																									RESULT = list;
																							   :}
							   | 
							   /*epsilon*/											
							   {:
							    	RESULT = new LinkedList<Statement>(); 
							   :};
							    
statement ::= stmt_list:list NEWLINE {: RESULT = list;
									 :}
			  | compound_statement:stmt {:	List<Statement> list = new LinkedList<Statement>();
											list.add((Statement)stmt);
											RESULT = list;
										:};
										
block ::= stmt_list:list NEWLINE {: RESULT = (List<Statement>)list;
 								 :}
		  | NEWLINE START_BLOCK statement_list:list END_BLOCK {: RESULT = (List<Statement>)list;	
		  	 										  		  :};
		  	 										  
statement_list ::= statement_list:list statement:stmt {:((List<Statement>)list).addAll((List<Statement>)stmt);
														RESULT = list;
													  :}
				   | statement : stmt {: List<Statement> list = new LinkedList<Statement>();
										list.addAll((List<Statement>)stmt);
										RESULT = list;
									  :};
									  
identifier_comma_list ::= COMMA ID identifier_comma_list
						  | /*epsilon*/;