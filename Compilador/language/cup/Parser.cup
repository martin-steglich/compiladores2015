package com.language.parser;

import java.util.*;
import java_cup.runtime.*;
import com.language.model.program.*;
import com.language.model.expression.*;
import com.language.model.statement.*;
import com.language.exceptions.*;
import java.util.LinkedList;
import java.util.List;
import java.util.Collections;

terminal String ID, INTEGER, LONG, FLOAT, STRING, TRUE, FALSE;

terminal String ASSIGN, PLUS, MINUS, MUL, DIV, EXP, INT_DIV, MOD;

terminal String AND_BIT, OR_BIT, XOR_BIT, NOT_BIT, LSHIFT_BIT, RSHIFT_BIT;

terminal String AND, OR, NOT, EQUALS, NOT_EQUALS, LESS_THAN, GREAT_THAN, LESSEQUAL_THAN, GREATEQUAL_THAN;

terminal String PRINT, TYPE;

terminal String NEWLINE;

terminal String START_BLOCK, END_BLOCK;

terminal String IF, ELSE, DEF;

terminal String LEFTPARENTHESE, RIGHTPARENTHESE;

terminal String COLON, SEMICOLON, COMMA;

non terminal program, module;
non terminal statement_newline_list, simple_statement_list, simple_statement, compound_statement;
non terminal stmt_list, simple_stmt_semicolon_list, statement, statement_list, identifier_comma_list;
non terminal Expression expression;
non terminal block;

precedence left PLUS, MINUS;
precedence left MUL, DIV, EXP, INT_DIV, MOD;
precedence left AND, OR, EQUALS, NOT_EQUALS, LESS_THAN, GREAT_THAN, LESSEQUAL_THAN, GREATEQUAL_THAN;
precedence left AND_BIT, OR_BIT, XOR_BIT, LSHIFT_BIT, RSHIFT_BIT;

program	::=	module:list {: 
							Collections.reverse((List<Statement>)list);
							RESULT = new Program((List<Statement>)list);
						:};
						
module ::= simple_statement:stmt simple_statement_list:list {:
						 										((List<Statement>)list).add((Statement)stmt);
																RESULT = list;
															:}
		   | statement_newline_list:list {: 
		   									RESULT = list; 
		   								 :};
		   								 
statement_newline_list ::=	NEWLINE statement_newline_list:list {:
																	RESULT = list; 
																:} 
							| statement:stmt statement_newline_list:list {:
																			((List<Statement>)list).addAll((List<Statement>)stmt);
																			RESULT = list;
																		 :}
							| 			
							/*epsilon*/							
							{: 
								RESULT = new LinkedList<Statement>(); 
							:}; 
															
simple_statement_list ::= simple_statement:stmt simple_statement_list:list {: 	
																				((List<Statement>)list).add((Statement)stmt);
																				RESULT = list;
																			:}
						  | 
						  /* epsilon */
						  {: 
						  	RESULT = new LinkedList<Statement>(); 
						  :};
						  
simple_statement ::= expression:e {: RESULT = e; :} 
					 | ID:i ASSIGN expression:e {: RESULT = new AssignStatement(i, (Expression)e); :}
					 | PRINT:p expression:e {: RESULT = new PrintStatement((Expression) e); :}
					 | TYPE:t LEFTPARENTHESE expression:e RIGHTPARENTHESE {: RESULT = new TypeStatement((Expression) e);	:};

expression ::= INTEGER:i {: RESULT = new IntegerExpression(Integer.valueOf(i)); :}
			| STRING:s {: RESULT = new StringExpression(s); :}
			| LONG:l {: RESULT = new LongExpression(Long.valueOf(l)); :}
			| FLOAT:f {: RESULT = new FloatExpression(Float.valueOf(f)); :}
			| TRUE:b {: RESULT = new BooleanExpression(true); :}
			| FALSE:b {: RESULT = new BooleanExpression(false); :}
			| expression:l PLUS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "+", (Expression)r) ;:}
			| expression:l MINUS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "-", (Expression)r) ;:}
			| expression:l DIV expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "/", (Expression)r) ;:}
			| expression:l MUL expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "*", (Expression)r) ;:}
			| expression:l EXP expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "**", (Expression)r) ;:}
			| expression:l INT_DIV expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "//", (Expression)r) ;:}
			| expression:l MOD expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "%", (Expression)r) ;:}
			| expression:l AND expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "and", (Expression)r) ;:}
			| expression:l OR expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "or", (Expression)r) ;:}
			| expression:l EQUALS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "==", (Expression)r) ;:}
			| expression:l NOT_EQUALS expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "!=", (Expression)r) ;:}
			| expression:l LESS_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "<", (Expression)r) ;:}
			| expression:l LESSEQUAL_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "<=", (Expression)r) ;:}
			| expression:l GREAT_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, ">", (Expression)r) ;:}
			| expression:l GREATEQUAL_THAN expression:r {: RESULT = new BinaryOperationExpression((Expression)l, ">=", (Expression)r) ;:}
			| expression:l AND_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "&", (Expression)r) ;:}
			| expression:l OR_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "|", (Expression)r) ;:}
			| expression:l XOR_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "^", (Expression)r) ;:}
			| expression:l LSHIFT_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, "<<", (Expression)r) ;:}
			| expression:l RSHIFT_BIT expression:r {: RESULT = new BinaryOperationExpression((Expression)l, ">>", (Expression)r) ;:}
			| MINUS expression:e {: RESULT = new UnaryOperationExpression("-", (Expression)e); :}
			| NOT_BIT expression:e {: RESULT = new UnaryOperationExpression("~", (Expression)e); :}
			| NOT expression:e {: RESULT = new UnaryOperationExpression("not", (Expression)e); :}
			| LEFTPARENTHESE expression:e RIGHTPARENTHESE {: RESULT = e; :};			

compound_statement ::= IF expression COLON block ELSE COLON block
					   | IF expression COLON block
					   | DEF ID LEFTPARENTHESE RIGHTPARENTHESE COLON block
					   | DEF ID LEFTPARENTHESE ID identifier_comma_list RIGHTPARENTHESE COLON block;
					   
stmt_list ::= simple_statement:stmt simple_stmt_semicolon_list:list {: 
																		((List<Statement>)list).add((Statement)stmt); 
																		RESULT = list;
																	:};
																	
simple_stmt_semicolon_list ::= SEMICOLON simple_statement:stmt simple_stmt_semicolon_list:list {: 
																									((List<Statement>)list).add((Statement)stmt); 
																									RESULT = list;
																							   :}
							   | 
							   /*epsilon*/											
							   {:
							    	RESULT = new LinkedList<Statement>(); 
							   :};
							   
statement ::= stmt_list:list NEWLINE {: 
										RESULT = list;
									 :}
			  | compound_statement:stmt {: 
											List<Statement> list = new LinkedList<Statement>();
											list.add((Statement)stmt);
											RESULT = list;
										:};
										
block ::= stmt_list:list NEWLINE {:
 									RESULT = (List<Statement>)list;
 								 :}
		  | NEWLINE START_BLOCK statement_list:list END_BLOCK {:
		  	 													RESULT = (List<Statement>)list;	
		  	 										  		  :};
		  	 										  
statement_list ::= statement_list:list statement:stmt {:
														((List<Statement>)list).addAll((List<Statement>)stmt);
														RESULT = list;
													  :}
				   | statement : stmt {:
										List<Statement> list = new LinkedList<Statement>();
										list.addAll((List<Statement>)stmt);
										RESULT = list;
									  :};
									  
identifier_comma_list ::= COMMA ID identifier_comma_list
						  | /*epsilon*/;