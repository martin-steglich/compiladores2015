package parser;

import python_program.*;
import python_program.expression.*;
import python_program.operators.*;
import python_program.statement.*;
import java.util.LinkedList;
import java.util.List;
import java.util.Collections;

import java_cup.runtime.*;

parser code
{:
:}

action code
{:
:}


terminal		PRINT,
				PLUS,
				MINUS,
				UMINUS,
				MULT,
				DIV,
				POW,
				MOD,
				LEFTPARENTHESE,
				RIGHTPARENTHESE,
				INPUT,
				INTEGER,
				COMMA,
				NOT,
				LESS,
				GREATER,
				EQUAL,
				GREATEROREQUAL,
				LESSOREQUAL,
				NOTEQUAL,
				OR,
				AND,
				TRUE,
				FALSE,
				IF,
				ELSE,
				FLOAT,
				COLON,
				IDENTIFIER,
				NEWLINE,
				PASS,
				ASSIGN,
				WHILE,
				SEMICOLON,
				INDENT,
				DEDENT,
				LEFTSQUAREBRACKET,
				RIGHTSQUAREBRACKET,
				LEFTCURLYBRACKET,
				RIGHTCURLYBRACKET,
				IS,
				LAMBDA,
				DEF,
				RETURN,
				FULLSTOP,
				CLASS;


non terminal	program,
				module,
				simple_statement,
				simple_statement_list,
				expression,
				expression_comma_list,
				unary_op,
				binary_op,
				compound_statement,
				stmt_list,
				simple_stmt_semicolon_list,
				statement,
				suite,
				statement_list,
				statement_newline_list,
				key_datum,
				key_datum_comma_list,
				subscription,
				target,
				identifier_comma_list,
				expression_list;
				
				
/* Precedences */
precedence left LAMBDA;
precedence left IF, ELSE;
precedence left ASSIGN;
precedence left FULLSTOP;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left LESS, GREATER, LESSOREQUAL, GREATEROREQUAL, EQUAL, NOTEQUAL, IS;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
precedence left UMINUS;
precedence left POW;
precedence left LEFTSQUAREBRACKET, RIGHTSQUAREBRACKET, LEFTCURLYBRACKET, RIGHTCURLYBRACKET, LEFTPARENTHESE, RIGHTPARENTHESE;

program						::=	module:list
								{: 	Collections.reverse((List<Statement>)list);
									RESULT = new Program((List<Statement>)list);
								:};

module						::= simple_statement:stmt simple_statement_list:list
									{: ((List<Statement>)list).add((Statement)stmt);
										RESULT = list;
									:}
								|
								statement_newline_list:list							//#3
								{: RESULT = list; :};

statement_newline_list		::=	NEWLINE statement_newline_list:list
								{:	RESULT = list; :} 
								|
								statement:stmt statement_newline_list:list			//#5
								{:	((List<Statement>)list).addAll((List<Statement>)stmt);
									RESULT = list;
								:}
								|
								/*epsilon*/											//#6
								{: RESULT = new LinkedList<Statement>(); :}; 

simple_statement_list		::= simple_statement:stmt simple_statement_list:list
									{: ((List<Statement>)list).add((Statement)stmt);
										RESULT = list;
									:}
								| 
								/* epsilon */
									{: RESULT = new LinkedList<Statement>(); :};
							
simple_statement			::= PRINT expression_comma_list:list			
									{: 
										RESULT = new PrintStatement((List<Expression>)list); 
									:}
								|
								PASS
									{:
										RESULT = new PassStatement();
									:}
								|
								IDENTIFIER:value ASSIGN expression:expr
									{:
										RESULT = new AssignStatement(new IdentifierExpression((String)value), (Expression)expr);
									:}
								|
								expression
								|
								target ASSIGN expression
								|
								RETURN expression;

expression_comma_list		::= expression_comma_list:list COMMA expression:expr
									{: ((List<Expression>)list).add((Expression)expr); 
										RESULT = list;
									:}
								|
								expression:expr							//#16
									{: List<Expression> list = new LinkedList<Expression>();
									   list.add((Expression)expr);
									   RESULT = list;
									:};					
								
expression					::= INTEGER:value												
									{: RESULT = new IntegerExpression((String)value); :}
								|
								MINUS expression:expr									
									{: RESULT = new UnaryExpression(UnaryOperators.sub, (Expression) expr); :} %prec UMINUS
								|
								PLUS expression:expr									
									{: RESULT = new UnaryExpression(UnaryOperators.add, (Expression) expr); :} %prec UMINUS
								|
								NOT expression:expr									
									{: RESULT = new UnaryExpression(UnaryOperators.not, (Expression) expr); :} %prec NOT
								|
								expression:expr1 PLUS expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.add, (Expression) expr2); :}
								|
								expression:expr1 MINUS expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.sub, (Expression) expr2); :}
								|
								expression:expr1 MUL expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mult, (Expression) expr2); :}
								|
								expression:expr1 DIV expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.div, (Expression) expr2); :}
								|
								expression:expr1 MOD expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mod, (Expression) expr2); :}
								|
								expression:expr1 EXP expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.pow, (Expression) expr2); :}
								|
								expression:expr1 LESS expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.less, (Expression) expr2); :}
								|
								expression:expr1 GREATER expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.greater, (Expression) expr2); :}
								|
								expression:expr1 EQUAL expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.equal, (Expression) expr2); :}
								|
								expression:expr1 GREATEROREQUAL expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.greaterorequal, (Expression) expr2); :}
								|
								expression:expr1 LESSOREQUAL expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.lessorequal, (Expression) expr2); :}
								|
								expression:expr1 NOTEQUAL expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.notequal, (Expression) expr2); :}
								|
								expression:expr1 OR expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.or, (Expression) expr2); :}
								|
								expression:expr1 AND expression:expr2				
									{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.and, (Expression) expr2); :}
								|
								LEFTPARENTHESE expression:expr RIGHTPARENTHESE
									{: RESULT = new ParenthesesExpression((Expression)expr); :}
								|
								INPUT LEFTPARENTHESE RIGHTPARENTHESE
									{: RESULT = new InputExpression(); :}
								|
								FLOAT:value
									{: RESULT = new FloatExpression(((String)value)); :}
								|
								TRUE
									{: RESULT = new TrueExpression(); :}
								|
								FALSE
									{: RESULT = new FalseExpression(); :}
								|
								IDENTIFIER:value
									{: RESULT = new IdentifierExpression((String)value);	:}
								|
								LEFTSQUAREBRACKET expression_comma_list RIGHTSQUAREBRACKET
								|
								LEFTCURLYBRACKET key_datum key_datum_comma_list RIGHTCURLYBRACKET
								|
								subscription
								|
								expression IS expression
								|
								expression LEFTPARENTHESE RIGHTPARENTHESE
								|
								expression LEFTPARENTHESE expression_comma_list RIGHTPARENTHESE
								|
								LAMBDA COLON expression
								|
								LAMBDA IDENTIFIER identifier_comma_list COLON expression
								|
								expression FULLSTOP IDENTIFIER;
				
compound_statement			::= IF expression COLON suite ELSE COLON suite
								|
								IF expression COLON suite
								|
								WHILE expression:expr COLON suite:list
									{:
										RESULT = new WhileStatement((Expression)expr, (List<Statement>)list);
									:}
								|
								DEF IDENTIFIER LEFTPARENTHESE RIGHTPARENTHESE COLON suite
								|
								DEF IDENTIFIER LEFTPARENTHESE IDENTIFIER identifier_comma_list RIGHTPARENTHESE COLON suite
								|
								CLASS IDENTIFIER COLON suite
								|
								CLASS IDENTIFIER LEFTPARENTHESE expression_list RIGHTPARENTHESE COLON suite;
								
stmt_list					::= simple_statement:stmt simple_stmt_semicolon_list:list			//#59
								{: ((List<Statement>)list).add((Statement)stmt); 
									RESULT = list;
								:};

simple_stmt_semicolon_list	::= SEMICOLON simple_statement:stmt simple_stmt_semicolon_list:list
									{: ((List<Statement>)list).add((Statement)stmt); 
										RESULT = list;
									:}
								|
								/*epsilon*/											//#61
									{: RESULT = new LinkedList<Statement>(); :};
						
statement					::= stmt_list:list NEWLINE								//#62
									{: RESULT = list; :}
								|
								compound_statement:stmt
									{: 
										List<Statement> list = new LinkedList<Statement>();
										list.add((Statement)stmt);
										RESULT = list;
									:};
																
suite						::= stmt_list:list NEWLINE
									{: RESULT = (List<Statement>)list;:}
								|
								NEWLINE INDENT statement_list:list DEDENT
									{: RESULT = (List<Statement>)list;	:};
								
statement_list				::= statement_list:list statement:stmt 
									{:
										((List<Statement>)list).addAll((List<Statement>)stmt);
										RESULT = list;
									:}
								|
								statement : stmt
									{:
										List<Statement> list = new LinkedList<Statement>();
										list.addAll((List<Statement>)stmt);
										RESULT = list;
									:};

key_datum					::= expression COLON expression;

key_datum_comma_list		::= COMMA key_datum key_datum_comma_list
								|
								/*epsilon*/;

subscription				::= expression LEFTSQUAREBRACKET expression RIGHTSQUAREBRACKET;

target						::= subscription
								|
								expression FULLSTOP IDENTIFIER;

identifier_comma_list		::= COMMA IDENTIFIER identifier_comma_list
								|
								/*epsilon*/;
								
expression_list				::= expression_comma_list;